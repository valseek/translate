
## 1 简介

HTTP是一个无状态应用层 request/response 协议，
它使用可扩展的予以和自描述的信息载体，
这么做的目的是为了在基于网络的超文本信息系统中进行灵活的交互。
这个文档是一系列HTTP1.1文档集合中的第一篇，整个系列的文档有：

* 1、 消息语法和路由 （本文档）
* 2、 语义和内容 【RFC7231】
* 3、 Conditional Requests （条件请求？）【RFC7232】
* 4、 Range Requests （范围请求？） 【RFC7233】
* 5、 缓存 【RFC7234】
* 6、 认证 【RFC7235】

这篇HTTP1.1 规范将会废弃地奥RFC2616和RFC2145（这些都在HTTP的版本控制里面）。
此篇规范同样也更新了建立连接的用法，之前定义在RFC2817，HTTPS的URI的格式规范在RFC2818中被不正式的定义。
HTTP是一个用在信息系统中的普适协议。他这么被设计出来是因为他要隐藏一个内部细节--服务器应该提供一个与它提供资源类型无关的统一接口给客户端。
同样，服务器也不需要知道每个客户端的意图：
每个HTTP请求可以被单独的考虑，而不是与某些特殊类型的客户端关联，或者关联到一个预先设定的应用步骤。
这样做的结果是这个协议可以在许多不同的上下文中非常高效 ，同时随着时间推移，协议也可以独立的优化推进。

HTTP同样也可以作为在非HTTP信息系统中的通信传送的交互协议。
HTTP代理和网关可以提供方法访问其他的信息系统，通过转化他们不同的协议到超文本格式，这个格式可以被HTTP服务的客户端用同样的方式浏览和操作。

这个协议灵活的结果是，协议不能确定接口之后干了些啥。
所以，我们不能定义同行的格式，接受信息的目的 ，和接受信息后的行为。
如果通信被当做独立的，那么每个成功的动作（请求？）都会在服务端提供的接口上有一个相对应的变化。
然而，如果有多个客户端同时发出相矛盾的请求时，我们不能保证在超出一个请求的时候（也就是在并发的时候）的预期。

本篇文档描述一些在HTTP中用到或者引用到基本的元素，定义HTTP和HTTPS的URI格式，
描述所有的网络操作和连接管理，并且定义HTTP消息的框架和转发要求。
这个文章的目的是为了定义所有与消息语义无关的HTTP消息处理的机制，从而定义一整套的消息格式分析和信息转发交互的需求。

### 1.1 需求注释

这篇文章出现的关键字"MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT","SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", 和 "OPTIONAL"，
在RFC2119中解释。

第2.5节定义了有关错误处理的一致性标准和考虑事项。

### 1.2 语法注释

这篇规范用了增强的BNF范式(在RFC5234中说明)和一些可扩展（在第7节中说明），
他可以用一个#操作符来更紧凑的定义逗号隔开的列表（类似于*代表重复）。
Appendix B中展示了所有在ABNF标准符号扩展出的操作符列表。

作为惯例，ABNF规则中用"obs-"作为前缀的表示 "obsolete"(废弃)的由于历史上废弃的语法规则。

## 2 体系结构

HTTP是为WWW体系结构创造的，同时随着时间推移去支持可扩展新的全球超文本系统的需求。
许多的架构都在用于定义HTTP的术语和语法中有所体现。

### 2.1 客户端/服务端消息传送

HTTP是一个无状态的request/response协议,通过在可靠地传输层或者会话层交互消息而运行。
一个HTTP客户端是一个向服务器建立连接并且发送若干个HTTP请求的程序。HTTP服务器是接受连接，处理HTTP请求并且返送HTTP响应的程序。

我们称客户端、服务端仅仅取决于在一个程序在一个实际的连接中程序所扮演的角色。
同一个程序既可以作为一些连接的客户端，也可以作为另一些连接的服务端。
user-agent 表示各种初始化请求，包括但不限于浏览器、爬虫、命令行工具、自定义的程序或者手机app 这类的客户端程序。
sender和recipient 表示任何发送或接受一个独立确定消息的实现。

HTTP依赖URI标准（RFC3986）指明目标资源（参见5.1节）和资源之间的关系。
消息一一种类似于网络邮件（RFC5233）和MIME（多用途网络邮件扩展【RFC2045】）的格式传递。

大多数HTTP通信包含一个索取被URI唯一确定的资源数据的请求（GET）。
在最简单的例子中，通过一个在user-agent（UA）和源服务器（O）之间的双向连接就可以完成一次HTTP通信。


    request   >

       UA ======================================= O
                                   <   response


客户端以请求的格式向服务端发送一个HTTP请求,
开始的第一行包括方法、URI、和协议版本（参见3.1.1节）；后面跟着头部字段，包括请求的修改人，客户端信息，和一些元信息（参见3.2节）；
接着是一个空行表示头部的结束，最后是一个包含消息正文的消息体（如果有，参见3.3节）。

服务器对客户端的回应可以发送若干个HTTP响应消息，
每一个消息的开始第一行是协议版本号，一个成功或者失败的代码，和一个由文本表示的原因短语（参见3.1.2节），
接下来有可能是一些包含服务器信息、资源元信息和元信息表现形式（参见3.2节）的头部字段。
接下来是一个空行，表示头部的结束，最后是一个包含消息正文的消息体（如果有，参见3.3节）。

一个连接可以用在多个request/response的交互中，参见6.3节。


接下来的一个例子阐述了一个典型的GET请求（参见RFC7231的4.3.1节）信息交互，请求的URI是 "http://www.example.com/hello.txt",
内容如下

Client request:

     GET /hello.txt HTTP/1.1
     User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
     Host: www.example.com
     Accept-Language: en, mi

Server response:

     HTTP/1.1 200 OK
     Date: Mon, 27 Jul 2009 12:28:53 GMT
     Server: Apache
     Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
     ETag: "34aa387-d-1568eb00"
     Accept-Ranges: bytes
     Content-Length: 51
     Vary: Accept-Encoding
     Content-Type: text/plain

     Hello World! My payload includes a trailing CRLF.


### 2.2 实现的多样化

当考虑设计HTTP的时候，很容易陷入一个思维误区，就是所有的用户都是普遍使用的浏览器、所有的源服务器都是大型的公共网站。
但是实际上并不是这个样子的。通用的HTTP User-Agent 包括家用电器、音响、音阶、固件更新脚本、命令行程序、手机app 和各种各样的通讯设备。
同样，通用的HTTP 源服务器包括家用自动化单元，可配置的网络组建、商用机器、自动机器人、新闻源、交通摄像头、广告选择器和视屏传送平台。

user-agent并不一定意味着在一个请求发送时一定有一个人类直接操作软件。
在许多时候，User-Agent 在后台暗转配置和运行，同时保存结果以待观察（或者仅仅保存一部分感兴趣或者错误的结果）。
举个例子，爬虫就是一个典型，他从一个给定的URI开始，配置一些行为，在爬去到一个页面之后。

HTTP实现的差异化意味着不是所有的User-Agent可以为安全和隐私给他们的用户一些交互性的建议，或者提供充足的警告





















<hr style="margin-top:160px;"/>

